import { VerificationRule, ValidationContext } from '../../../types';
import { VerificationIssue } from '../../../../core/models/Verification';
import { generateUUID } from '../../../../utils/uuid';

/**
 * Rule to detect potential XSS (Cross-Site Scripting) vulnerabilities
 */
export class XssVulnerabilityRule implements VerificationRule {
  id = 'xss-vulnerability';
  name = 'XSS Vulnerability Detection';
  category = 'security' as const;
  severity = 'High' as const;
  enabled = true;

  // Patterns to detect potential XSS vulnerabilities
  private patterns: { name: string; regex: RegExp; suggestion: string }[] = [
    {
      name: 'Unsafe innerHTML assignment',
      regex: /innerHTML\s*[=:]\s*.*\$\{/i,
      suggestion: 'Use textContent instead of innerHTML, or sanitize user input with a library like DOMPurify'
    },
    {
      name: 'React dangerouslySetInnerHTML',
      regex: /dangerouslySetInnerHTML/i,
      suggestion: 'Avoid dangerouslySetInnerHTML. If necessary, sanitize the HTML content first'
    },
    {
      name: 'Unsafe HTML in Vue v-html directive',
      regex: /v-html\s*=\s*["'].*\$\{/i,
      suggestion: 'Use {{ }} interpolation instead of v-html, or sanitize the content before binding'
    },
    {
      name: 'Document write with user input',
      regex: /document\.write\s*\(.*\$/i,
      suggestion: 'Avoid document.write(). Use DOM manipulation methods with textContent instead'
    },
    {
      name: 'Eval usage with user input',
      regex: /eval\s*\(.*\$/i,
      suggestion: 'Avoid using eval() with user input. It can lead to code injection vulnerabilities'
    },
    {
      name: 'New Function with user input',
      regex: /new\s+Function\s*\(.*\$/i,
      suggestion: 'Avoid creating functions from user input. Use safer alternatives'
    }
  ];

  async validate(context: ValidationContext): Promise<VerificationIssue[]> {
    const issues: VerificationIssue[] = [];
    const content = context.fileContent;

    for (const pattern of this.patterns) {
      const matches = content.match(pattern.regex);
      if (matches) {
        // Find line number
        const lines = content.split('\n');
        let lineNumber = 1;
        for (let i = 0; i < lines.length; i++) {
          if (lines[i]?.match(pattern.regex)) {
            lineNumber = i + 1;
            break;
          }
        }

        issues.push({
          id: generateUUID(),
          severity: this.severity,
          category: this.category,
          file: context.filePath,
          line: lineNumber,
          message: `Potential XSS: ${pattern.name}`,
          suggestion: pattern.suggestion,
          code: matches[0]?.substring(0, 100) // Limit code preview
        });
      }
    }

    return issues;
  }
}
